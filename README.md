# jsdb
Simple file-based json database

## Overview

A simple database of JSON objects, which are stored in a file.

Basic indexes allow searching. After that you're on your own.

Inspired by the execellent [nedb](https://www.npmjs.com/package/nedb) module, but with:
- much simple API with **far** less functionality
- promises and async as standard
- compound indexes, but only flat records
- much smaller footprint
- no predicates, just lookups

Only for my own use. Don't use it. Use nedb instead

When objects are stored in the DB, they are frozen

**NOTE** Version 4 database structure has changed.

## API

### Database

`db = new Database(filename)`


### .ensureIndex

`await db.ensureIndex({ name, unique = true|false, field|fields })`

Creates a named index. Will replace an existing index of the same
name. The primary index (which will/must always exist) is called....`primary`.

An index can be on a single field, or a combination of multiple fields.
The index is formed by combining the string representations of the fields
together.

A `unique` index will barf on non-unique values. Primary indexes are by
definition unique.

If the primary index is a single field, and it is suppled as `null` or `undefined`
then a random value will be autogenerated.

### .deleteIndex

`db.deleteIndex(fieldName)`

removes the index

### .insert

`await db.insert(doc|docs)`

Inserts a new doc or docs. Returns the actual stored doc/docs.

### .update

`await db.update(doc|docs)`

Replaces existing doc (or docs) based on the primary index.
Returns the new stored one(s).

### .upsert

`await db.upsert(doc|docs)`

Either insert or update doc (or docs). Returns the new stored one(s).

### .delete

`await db.delete(doc|docs)`

Deletes the doc (or docs) based on the matching the primary index.
Returns the old stored doc.

### .getAll

`allDocs = await db.getAll()`

returns an array of all docs.

### .find

`matching = await db.find(<indexName>, <value|partialRow>)`

Returns a list of the matching docs which can be empty.

Unique indices act like `.findOne` and return a single doc or `undefined`.

### .findOne

`matching = await db.findOne(<indexName>, <value|partialRow>)`

Returns the first matching doc, or `undefined`

### .compact

`await db.compact(opts)`
comapcts and rewrites the database.

Options:

`sortBy` a sort function with signature `(a,b) => -1|0|+1`


### .setAutoCompaction

`db.setAutoCompaction(30 * 60 * 1000, compactOptions) // 30 minutes`

Sets auto-scheduled compaction

### .stopAutoCompaction

`db.stopAutoCompaction()`

Stops any scheduled compaction

## Errors

The following errors can be thrown.
The constructors are found as static properties on `Database`

### NotExists

Thrown when trying to update or delete a record that does not exist.

- `.record` has the missing record

### KeyViolation

Thrown when an insert or update would violate a unique key.

- `.name` has the name of the index
- `.record` has the offending record

### NoIndex

Thrown when a `find` or `findOne` asks to use an index which does not exist

- `.name` has the name of the missing index

### DatabaseLocked

Thrown when a lockfile already exists for this database

- `.filename` is the offending database
